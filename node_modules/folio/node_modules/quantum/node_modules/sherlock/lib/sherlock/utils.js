/**
 * # colorize(str, color)
 *
 * Provides helper to frame string with fg color
 * for use in the cli.
 *
 * @param {String} string to colorize
 * @param {String} color
 * @api utilites
 */

exports.colorize = function (str, color) {
  var options = {
      red:      '\u001b[31m'
    , green:    '\u001b[32m'
    , yellow:   '\u001b[33m'
    , blue:     '\u001b[34m'
    , magenta:  '\u001b[35m'
    , cyan:     '\u001b[36m'
    , gray:     '\u001b[90m'
    , reset:    '\u001b[0m'
  };
  return options[color] + str + options.reset;
};

/**
 * # highlight(str, color)
 *
 * Provides helper to frame string with bg color
 * for use in the cli.
 *
 * @param {String} string to colorize
 * @param {String} color
 * @api utilites
 */

exports.highlight = function (str, color) {
  var options = {
      red:      '\u001b[41m'
    , green:    '\u001b[42m'
    , yellow:   '\u001b[43m'
    , blue:     '\u001b[44m'
    , magenta:  '\u001b[45m'
    , cyan:     '\u001b[46m'
    , gray:     '\u001b[100m'
    , reset:    '\u001b[0m'
  };
  return options[color] + str + options.reset;
};

/**
 * # padBefore(str, width)
 *
 * Provides helper to frame string with spaces
 * before for use in the cli.
 *
 * @param {String} string to pad
 * @param {Number} width in characters
 * @api utilites
 */

exports.padBefore = function (str, width) {
  return Array(width - str.length).join(' ') + str;
};

/**
 * # padAfter(str, width)
 *
 * Provides helper to frame string with spaces
 * after for use in the cli.
 *
 * @param {String} string to pad
 * @param {Number} width in characters
 * @api utilites
 */

exports.padAfter = function (str, width) {
  return str + Array(width - str.length).join(' ');
};

/**
 * getType (obj)
 *
 * Return the type of an object using
 * standardized checks.
 *
 * @param {Mixed} object
 * @returns String type
 * @api utilities
 */

exports.getType = function (obj) {
  var toString = Object.prototype.toString;

  var core = [
      'string'
    , 'number'
    , 'boolean'
    , 'function'
    , 'undefined'
  ];

  if (~core.indexOf(typeof obj)) {
    return typeof obj;
  } else if (toString.call(obj) === '[object RegExp]') {
    return 'regexp';
  } else if (Array.isArray(obj)) {
    return 'array';
  } else if (toString.call(obj) === '[object Null]') {
    return 'null';
  } else if (toString.call(obj) === '[object Object]') {
    return 'object';
  }
};

exports.decycle = function (obj) {
  var objects = [],
      paths = [];

  function derez (value, path) {
    var name, nu;

    switch (typeof value) {
      case 'object':
        if (!value) return null;

        for (var i = 0; i < objects.length; i += 1) {
          if (objects[i] === value) return '[Circular]';
        }

        objects.push(value);
        paths.push(path);

        if (Object.prototype.toString.apply(value) === '[object Array]') {
          nu = [];
          for (var i = 0; i < value.length; i += 1) {
            nu[i] = derez(value[i], path + '[' + i + ']');
          }
        } else {
          nu = {};
          for (name in value) {
            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
          }
        }
        return nu;
      default:
        return value;
      break;
    }
  }

  return derez(obj, '[Circular]');
};
